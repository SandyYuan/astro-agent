import arxiv
import os
import json
import time
from typing import Dict, List, Any, Optional

# Import from your existing setup
from config import *
from google import genai
from idea_agent import client

def evaluate_research_idea(idea: Dict[str, Any], max_papers: int = 10) -> Dict[str, Any]:
    """
    Evaluate a research idea by comparing it with recent arXiv papers and providing feedback
    along the dimensions of novelty, impact, and practicality.
    
    Args:
        idea: The research idea dictionary generated by the idea generator
        max_papers: Maximum number of results to retrieve
        
    Returns:
        Dictionary containing evaluation results and feedback
    """
    # Extract relevant information from the idea
    title = idea.get("title", "")
    research_question = idea.get("idea", {}).get("Research Question", "")
    
    # Create search query from title and research question
    search_terms = extract_search_terms(title, research_question)
    query = " OR ".join([f'"{term}"' for term in search_terms])
    
    # Search arXiv for related papers
    try:
        related_papers = search_arxiv(query, max_papers)
    except Exception as e:
        print(f"Error searching arXiv: {str(e)}")
        related_papers = []
    
    # Generate feedback using LLM
    feedback = generate_feedback(idea, related_papers)
    
    # Return evaluation results
    return {
        "original_idea": idea,
        "related_papers": [paper_to_dict(paper) for paper in related_papers],
        "feedback": feedback
    }

def extract_search_terms(title: str, research_question: str) -> List[str]:
    """Extract key search terms from the title and research question"""
    # Combine title and first 200 characters of research question
    combined_text = f"{title} {research_question[:200]}"
    
    # Remove common words and punctuation (simplified approach)
    common_words = [
        "and", "the", "in", "of", "to", "a", "for", "with", "on", "by", "this", 
        "project", "research", "study", "analysis", "we", "will", "using"
    ]
    
    # Split by spaces, convert to lowercase, and filter
    words = combined_text.lower().split()
    filtered_words = [word.strip(".,;:()[]{}\"'") for word in words if word.lower() not in common_words and len(word) > 3]
    
    # Get unique terms
    unique_terms = list(set(filtered_words))
    
    # Select most relevant terms (longer words often more specific)
    unique_terms.sort(key=len, reverse=True)
    search_terms = unique_terms[:5]  # Take top 5 longest terms
    
    # Add specific astronomy terms from the title if present
    astronomy_terms = [
        "galaxy", "exoplanet", "star", "cosmology", "quasar", "black hole", 
        "nebula", "pulsar", "supernova", "redshift", "dwarf"
    ]
    
    for term in astronomy_terms:
        if term in title.lower() and term not in search_terms:
            search_terms.append(term)
    
    return search_terms[:7]  # Return at most 7 search terms

def search_arxiv(query: str, max_results: int = 10) -> List[Any]:
    """
    Search arXiv for papers matching the query
    
    Args:
        query: The search query
        max_results: Maximum number of results to retrieve
        
    Returns:
        List of arXiv paper objects
    """
    # Configure the client
    client = arxiv.Client(
        page_size=100,
        delay_seconds=3.0,
        num_retries=3
    )
    
    # Set up the search
    search = arxiv.Search(
        query=query,
        max_results=max_results,
        sort_by=arxiv.SortCriterion.SubmittedDate,
        sort_order=arxiv.SortOrder.Descending
    )
    
    # Execute the search and return results
    results = list(client.results(search))
    return results

def paper_to_dict(paper) -> Dict[str, Any]:
    """Convert an arXiv paper object to a dictionary"""
    return {
        "title": paper.title,
        "authors": ', '.join(author.name for author in paper.authors),
        "published": paper.published.strftime("%Y-%m-%d") if hasattr(paper, "published") else None,
        "url": paper.entry_id,
        "abstract": paper.summary
    }

def generate_feedback(idea: Dict[str, Any], related_papers: List[Any]) -> Dict[str, str]:
    """
    Generate feedback on the research idea using the LLM
    
    Args:
        idea: The research idea dictionary
        related_papers: List of related arXiv papers
        
    Returns:
        Dictionary with feedback on novelty, impact, and practicality
    """
    # Prepare the input for the LLM
    title = idea.get("title", "")
    research_question = idea.get("idea", {}).get("Research Question", "")
    methodology = idea.get("idea", {}).get("Methodology", "")
    expected_outcomes = idea.get("idea", {}).get("Expected Outcomes", "")
    
    # Format the arXiv paper information
    papers_text = ""
    for i, paper in enumerate(related_papers[:5], 1):  # Limit to 5 papers for context length
        papers_text += f"\nPaper {i}:\nTitle: {paper.title}\nAuthors: {', '.join(author.name for author in paper.authors)}\nAbstract: {paper.summary}\n"
    
    # Create the prompt for the LLM
    prompt = f"""You are a senior astronomy research advisor evaluating a proposed research idea for a graduate student. Your task is to evaluate this idea and provide constructive feedback to improve it.

Research Idea:
Title: {title}

Research Question:
{research_question}

Methodology (summary):
{methodology[:500]}...

Expected Outcomes (summary):
{expected_outcomes[:500]}...

Recently published arXiv papers in related areas:
{papers_text}

Based on the research idea and these recent papers, provide a critical evaluation in these three areas:

1. Novelty: Evaluate how original the idea is compared to recent work. Is it addressing a genuinely open question? Does it take a new approach? Has this specific question already been addressed in recent literature?

2. Impact: Assess the potential scientific impact of this research. Would it advance the field? Does it address important challenges? Is the scope appropriate for a graduate project?

3. Practicality: Evaluate whether the proposed methodology is feasible with the stated resources and timeframe. Are there technical issues that weren't considered? Would you recommend different methods or data sources?

For each area, provide 2-3 sentences of specific, constructive feedback. Be direct but supportive, highlighting both strengths and areas for improvement. Include specific suggestions whenever possible.
"""

    try:
        # Use the client to generate feedback
        response = client.models.generate_content(
            model="gemini-2.0-flash-thinking-exp", contents=prompt
        )
        response_text = response.text
        
        # Process the response to extract feedback for each category
        feedback = parse_feedback(response_text)
    except Exception as e:
        print(f"Error generating feedback: {str(e)}")
        feedback = {
            "novelty": "Unable to evaluate novelty due to API error.",
            "impact": "Unable to evaluate impact due to API error.",
            "practicality": "Unable to evaluate practicality due to API error."
        }
    
    return feedback

def parse_feedback(response_text: str) -> Dict[str, str]:
    """Parse LLM response to extract feedback for each category"""
    feedback = {
        "novelty": "",
        "impact": "",
        "practicality": ""
    }
    
    # Simple parsing based on numbered sections and keywords
    sections = response_text.lower().split("\n\n")
    
    for section in sections:
        if "novelty" in section[:20]:
            feedback["novelty"] = section
        elif "impact" in section[:20]:
            feedback["impact"] = section
        elif "practicality" in section[:20]:
            feedback["practicality"] = section
    
    # If simple parsing failed, try another approach
    if not any(feedback.values()):
        paragraphs = response_text.split("\n\n")
        if len(paragraphs) >= 3:
            feedback["novelty"] = paragraphs[0]
            feedback["impact"] = paragraphs[1]
            feedback["practicality"] = paragraphs[2]
    
    # Clean up the feedback
    for key in feedback:
        # Remove category labels from the beginning
        clean_text = feedback[key]
        for prefix in [f"{key}:", f"{key.capitalize()}:", f"{key.upper()}:", f"{key.title()}:"]:
            if clean_text.lower().startswith(prefix.lower()):
                clean_text = clean_text[len(prefix):].strip()
        
        # Remove numbering patterns
        for pattern in ["1. ", "2. ", "3. ", "(1) ", "(2) ", "(3) "]:
            if clean_text.startswith(pattern):
                clean_text = clean_text[len(pattern):]
        
        feedback[key] = clean_text.strip()
    
    return feedback

def improve_research_idea(idea: Dict[str, Any], feedback: Dict[str, str]) -> Dict[str, Any]:
    """
    Improve the research idea based on the feedback
    
    Args:
        idea: The original research idea
        feedback: Feedback from the reflection step
        
    Returns:
        Improved research idea
    """
    # Extract key components from original idea
    title = idea.get("title", "")
    research_question = idea.get("idea", {}).get("Research Question", "")
    background = idea.get("idea", {}).get("Background", "")
    methodology = idea.get("idea", {}).get("Methodology", "")
    expected_outcomes = idea.get("idea", {}).get("Expected Outcomes", "")
    challenges = idea.get("idea", {}).get("Potential Challenges", "")
    required_skills = idea.get("idea", {}).get("Required Skills", "")
    broader_connections = idea.get("idea", {}).get("Broader Connections", "")
    
    # Format the feedback
    feedback_text = f"""
Novelty feedback: {feedback.get('novelty', '')}

Impact feedback: {feedback.get('impact', '')}

Practicality feedback: {feedback.get('practicality', '')}
"""
    
    # Create the prompt for improving the idea
    prompt = f"""You are an astronomy research advisor tasked with improving a graduate student research idea based on expert feedback. Review the original research idea and the feedback provided, then create an improved version that addresses all feedback points.

ORIGINAL RESEARCH IDEA:
Title: {title}

Research Question:
{research_question}

Background:
{background[:500]}...

Methodology:
{methodology[:500]}...

Expected Outcomes:
{expected_outcomes[:300]}...

EXPERT FEEDBACK:
{feedback_text}

Based on this feedback, improve the research idea. Keep the same structure but refine the content to address all feedback points. Focus particularly on:
1. Increasing novelty by ensuring the research addresses genuinely open questions
2. Enhancing potential impact by connecting to important challenges in the field
3. Improving practicality by ensuring the methods are feasible and appropriate

Your response MUST follow this exact format with all sections thoroughly completed:

# [IMPROVED DESCRIPTIVE PROJECT TITLE]

## Research Question
Begin with a clear, explicit mission statement that specifies the data, methods, and objectives.
Then explain why this research is important and impactful.

## Background
Provide 3-4 paragraphs on the current state of knowledge, key gaps being addressed,
and why this project is suitable for a graduate student.

## Methodology
Outline a detailed step-by-step approach including specific data sources, tools,
analytical methods, validation techniques, and timeline.

## Expected Outcomes
Describe at least three concrete, measurable results this research could produce.

## Potential Challenges
Identify specific obstacles and mitigation approaches.

## Required Skills
List technical and knowledge-based skills needed.

## Broader Connections
Explain how this research connects to larger questions in astronomy.

Make sure your improved idea is scientifically accurate, technically feasible, appropriately scoped, and addresses all the feedback points.
"""
    
    try:
        # Use the client to generate an improved idea
        response = client.models.generate_content(
            model="gemini-2.0-flash-thinking-exp", contents=prompt
        )
        idea_text = response.text
        
        # Parse the improved idea
        improved_idea = parse_research_idea(idea_text)
        
        # Preserve metadata from original idea
        improved_idea["subfields"] = idea.get("subfields", [])
        improved_idea["skill_level"] = idea.get("skill_level", "")
        improved_idea["time_frame"] = idea.get("time_frame", "")
        improved_idea["resources_needed"] = idea.get("resources_needed", [])
        
        # Add feedback and improvement metadata
        improved_idea["feedback"] = feedback
        improved_idea["is_improved"] = True
        improved_idea["original_title"] = title
        
        return improved_idea
    except Exception as e:
        print(f"Error improving research idea: {str(e)}")
        return idea  # Return original idea if improvement fails

def parse_research_idea(idea_text: str) -> Dict[str, Any]:
    """Parse the generated research idea text into a structured dictionary"""
    # Define the sections we expect to find
    sections = [
        "Research Question",
        "Background",
        "Methodology",
        "Expected Outcomes",
        "Potential Challenges",
        "Required Skills",
        "Broader Connections"
    ]
    
    parsed_idea = {}
    current_section = None
    section_content = []
    
    # Extract the title first (should be on the first line with # prefix)
    title = ""
    for line in idea_text.split('\n'):
        if line.startswith('# '):
            title = line.replace('# ', '').strip()
            break
    
    # Now parse the rest of the content
    for line in idea_text.split('\n'):
        # Skip the title line we already processed
        if line.startswith('# '):
            continue
            
        # Check if line starts a new section
        new_section = False
        
        if line.startswith('## '):
            section_name = line.replace('## ', '').strip()
            if section_name in sections:
                if current_section and section_content:
                    parsed_idea[current_section] = '\n'.join(section_content).strip()
                current_section = section_name
                section_content = []
                new_section = True
        
        if not new_section and current_section is not None:
            section_content.append(line)
    
    # Add the last section
    if current_section and section_content:
        parsed_idea[current_section] = '\n'.join(section_content).strip()
    
    # Add metadata to the result
    result = {
        "title": title if title else "Improved Research Project",
        "idea": parsed_idea
    }
    
    return result

if __name__ == "__main__":
    # Example usage for testing
    from idea_agent import generate_research_idea
    
    # Generate a research idea
    idea = generate_research_idea(
        student_interests=["Observational Cosmology", "Galaxy Formation and Evolution"],
        skill_level="beginner",
        time_frame="2 years"
    )
    
    # Evaluate the idea and provide feedback
    evaluation = evaluate_research_idea(idea)
    feedback = evaluation["feedback"]
    
    # Print the original idea title and feedback
    print(f"Original Idea: {idea['title']}")
    print("\nFeedback:")
    for category, text in feedback.items():
        print(f"{category.capitalize()}: {text}")
    
    # # Improve the idea based on feedback
    # improved_idea = improve_research_idea(idea, feedback)
    
    # # Print the improved idea title
    # print(f"\nImproved Idea: {improved_idea['title']}")